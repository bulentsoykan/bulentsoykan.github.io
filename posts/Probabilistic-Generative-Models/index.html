<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bulent Soykan">
<meta name="dcterms.date" content="2025-06-12">

<title>Tabular Data and PGMs – Bulent Soykan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../icon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bulent Soykan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bulentsoykan"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/bulentsoykan"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/bulent-soykan/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Tabular Data and PGMs</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">news</div>
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Bulent Soykan </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 12, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-tabular-data-fallacy-why-weve-only-scratched-the-surface-of-ais-real-goldmine" class="level1">
<h1>The Tabular Data Fallacy: Why We’ve Only Scratched the Surface of AI’s Real Goldmine</h1>
<p>There’s a pervasive narrative in the world of AI, a comforting story we tell ourselves on Kaggle leaderboards and in startup pitch decks. It’s the story of the “solved problem,” and its main character is tabular data. With the undisputed power of libraries like XGBoost and LightGBM, and a relentless focus on benchmark accuracy, we’ve convinced ourselves that the major challenges of data in rows and columns are behind us.</p>
<p>This narrative is a fallacy. And it’s holding us back.</p>
<p>It’s true that if your goal is to squeeze another fraction of a percent of accuracy out of a perfectly clean, fully labeled dataset, then yes, the path is well-worn. But that’s not the world real businesses operate in. The real world is a chaotic landscape of incomplete records, unlabeled information, and shocking, unpredicted events.</p>
<p>For years, I’ve watched the AI community chase incremental gains on sanitized problems while ignoring the foundational, high-value challenges that plague every major industry. The reason for this oversight is our collective fixation on a single class of tools: <strong>discriminative models</strong>.</p>
<p>I’m writing this to tell you there’s a better way. The future of AI in the enterprise, the truly transformative and defensible innovations, will come from a different approach entirely. They will be built on <strong>probabilistic generative models</strong>.</p>
<hr>
<section id="the-allure-and-limits-of-the-discriminative-path" class="level3">
<h3 class="anchored" data-anchor-id="the-allure-and-limits-of-the-discriminative-path">The Allure and Limits of the Discriminative Path</h3>
<p>To understand where we need to go, we must first be honest about where we are. The vast majority of machine learning applications on tabular data rely on discriminative models.</p>
<p>A discriminative model learns to separate data points. Its entire purpose is to find a boundary—a line or a complex, high-dimensional surface—that optimally divides one class from another. It learns the conditional probability, <span class="math inline">\(P(Y|X)\)</span>.</p>
<p><strong>Think of a bank’s loan approval model.</strong> Its goal is to predict default risk.</p>
<ul>
<li><strong>The Input (X):</strong> Applicant data like <code>credit_score</code>, <code>income</code>, <code>age</code>, <code>years_at_job</code>.</li>
<li><strong>The Output (Y):</strong> A binary label, <code>Default</code> or <code>No Default</code>.</li>
</ul>
<p>The model takes this data and learns a function that, for any new applicant, draws a line and decides which side they fall on. It is incredibly effective at this one job. This is why Gradient Boosted Decision Trees (GBDTs) dominate—they are master boundary-finders.</p>
<p>But this singular focus is also their greatest weakness. A discriminative model is like a student who has crammed for a multiple-choice test. They can pick the right answer from a list of options with remarkable accuracy, but they lack any foundational knowledge of the subject. They don’t know <em>why</em> an answer is correct, only that it matches the patterns they memorized.</p>
<p>This leads to critical failures when faced with real-world messiness: * <strong>It sees a blank on the test (missing data) and panics</strong>, forcing you to guess the answer for it. * <strong>It cannot learn from the textbook (unlabeled data)</strong>, only from the pre-answered practice tests. * <strong>It has no way of knowing if a question is from a completely different subject (Out-of-Distribution data)</strong> and will confidently provide a nonsensical answer.</p>
<p>This isn’t a solid foundation for building robust, intelligent systems. It’s a house of cards.</p>
</section>
<section id="the-generative-leapfrom-prediction-to-true-understanding" class="level3">
<h3 class="anchored" data-anchor-id="the-generative-leapfrom-prediction-to-true-understanding">The Generative Leap—From Prediction to True Understanding</h3>
<p>A probabilistic generative model takes a radically different approach. It doesn’t just learn the boundary <em>between</em> classes; it learns the inherent structure of the data itself. Its goal is to learn the full joint probability distribution, <span class="math inline">\(P(X, Y)\)</span>.</p>
<p>Let’s return to our bank example. A generative model wouldn’t just learn how to separate defaulters from non-defaulters. It would learn the “story” of the entire applicant pool. It would understand the complex interplay between all the variables: how income relates to age, how that combination relates to the requested loan amount, and how all those factors together define a “typical” applicant.</p>
<p>Because it learns the distribution of the data, it can <em>generate</em> new, plausible data points. It can create a profile of a synthetic-but-realistic applicant. This creative ability is the key that unlocks solutions to previously intractable problems.</p>
<p>The family of generative models is diverse and powerful:</p>
<ul>
<li><strong>Variational Autoencoders (VAEs):</strong> Think of a VAE as a master artist and forger. The “encoder” part of the network looks at a real applicant’s profile and creates a compressed, abstract sketch of them (in what we call the latent space). The “decoder” part is trained to take that sketch and perfectly reconstruct the original profile. By mastering this process of sketching and reconstructing, the decoder becomes a generator. We can give it new, random sketches, and it will create entirely new, realistic applicant profiles.</li>
<li><strong>Generative Adversarial Networks (GANs):</strong> This is the famous model with two dueling neural networks. A <strong>Generator</strong> creates fake applicant profiles from scratch. A <strong>Discriminator</strong> (a discriminative model!) acts as a detective, trying to tell the difference between the real applicants and the fakes. The two are locked in an escalating arms race, with the Generator becoming an incredibly sophisticated forger, capable of producing synthetic data that is indistinguishable from reality.</li>
<li><strong>Flow-based Models:</strong> Imagine starting with a simple block of marble (a simple, known probability distribution like a Gaussian). A flow-based model is like a master sculptor who applies a series of precise, <em>reversible</em> chisels and cuts (invertible transformations) to shape the block into a complex statue (the distribution of your applicant data). Because every step is reversible, you can not only create a statue from the block but also calculate the exact sequence of steps to turn the statue back into the block, giving you a precise mathematical grasp of the data’s probability.</li>
</ul>
<hr>
</section>
<section id="solving-the-impossible-problemsgenerative-models-in-action" class="level3">
<h3 class="anchored" data-anchor-id="solving-the-impossible-problemsgenerative-models-in-action">Solving the “Impossible” Problems—Generative Models in Action</h3>
<p>This all sounds great in theory. But let’s look at how this directly solves the high-value problems that leave purely discriminative models helpless.</p>
<section id="conquering-missing-features" class="level4">
<h4 class="anchored" data-anchor-id="conquering-missing-features">Conquering Missing Features</h4>
<ul>
<li><strong>The Status Quo:</strong> An applicant for a loan, a 25-year-old software engineer, leaves the <code>years_at_current_job</code> field blank. The standard approach is crude: impute the column’s average, which might be 5.2 years. This instantly makes the applicant’s profile nonsensical and contradictory.</li>
<li><strong>The Generative Approach:</strong> A trained generative model looks at the rest of the applicant’s data: <code>age: 25</code>, <code>profession: software_engineer</code>, <code>education: master's_degree</code>. Having learned the joint distribution of tens of thousands of applicants, it understands the strong correlation between these features. It performs <em>conditional sampling</em>. It essentially asks, “For the universe of 25-year-old software engineers with a Master’s degree in my dataset, what is the probability distribution of their ‘years at current job’?” The answer is likely a distribution heavily skewed towards 1-3 years. The model then samples from <em>this specific, conditional distribution</em> to fill in the blank. It doesn’t guess; it makes a highly informed, contextually-aware inference.</li>
</ul>
</section>
<section id="the-economics-of-unlabeled-data" class="level4">
<h4 class="anchored" data-anchor-id="the-economics-of-unlabeled-data">The Economics of Unlabeled Data</h4>
<ul>
<li><strong>The Pain Point:</strong> A hospital wants to build an AI model to predict the risk of sepsis, a life-threatening condition. They have electronic health records for 2 million patients, a treasure trove of unlabeled data (vitals, lab results, etc.). However, getting expert doctors to retrospectively review each case and apply a definitive <code>Sepsis</code> or <code>No Sepsis</code> label is prohibitively expensive. They can only afford to label 5,000 records.</li>
<li><strong>The Generative Solution (Semi-Supervised Learning):</strong> This is where generative models create immense economic value.
<ol type="1">
<li><strong>Unsupervised Pre-training:</strong> We first train a generative model (like a VAE) on all <em>2 million</em> unlabeled patient records. The model’s task is simply to understand the data’s structure—to learn what a “normal” patient’s trajectory looks like, what common patterns in lab results are, and how different vitals relate to each other. It builds a rich, internal representation of human physiology as captured in the data.</li>
<li><strong>Supervised Fine-tuning:</strong> Now, we take the 5,000 labeled records. We use this small, precious dataset to fine-tune the pre-trained model. Because the model has already done 99% of the work by learning the data’s landscape, the labeled data simply acts as a guide, putting names to the regions the model has already discovered. The result is a highly accurate sepsis prediction model that approaches the performance of a model trained on millions of labeled records, but for a tiny fraction of the cost.</li>
</ol></li>
</ul>
</section>
<section id="the-ultimate-safety-netout-of-distribution-ood-detection" class="level4">
<h4 class="anchored" data-anchor-id="the-ultimate-safety-netout-of-distribution-ood-detection">The Ultimate Safety Net—Out-of-Distribution (OOD) Detection</h4>
<ul>
<li><strong>The Silent Failure:</strong> A hedge fund trains a trading algorithm on market data from 2010-2019. The model performs brilliantly in back-testing. In 2020, the COVID-19 pandemic creates unprecedented market volatility. The discriminative model, only knowing how to classify patterns it has seen before, continues to operate with high confidence, misinterpreting the new reality and leading to catastrophic losses. It has no mechanism for recognizing that the fundamental rules of the game have changed.</li>
<li><strong>The Generative Alarm Bell:</strong> A generative model is also trained on the 2010-2019 data. It doesn’t just learn trading signals; it learns the probability distribution of a “normal” market day. When the pandemic-era data starts streaming in, the model calculates the likelihood of this new data under its learned distribution. The probability is infinitesimally small. It immediately flags this data as Out-of-Distribution. It essentially raises a giant red flag and says: <strong>“EMERGENCY. The world I was trained on no longer exists. My predictions are unreliable. Human intervention is required.”</strong> It knows what it doesn’t know, which is arguably the most critical feature of any AI system deployed in a high-stakes, dynamic environment.</li>
</ul>
</section>
</section>
<section id="a-call-for-true-innovation" class="level3">
<h3 class="anchored" data-anchor-id="a-call-for-true-innovation">A Call for True Innovation</h3>
<p>For too long, we have defined “progress” in AI by climbing a few points up a leaderboard on a static dataset. This is not innovation; it’s optimization.</p>
<p>The real opportunities—the massive markets—lie in solving the foundational problems that every enterprise faces. They are in building systems that are robust to the chaos of reality, that can learn from all available data, not just the perfectly curated bits, and that are smart enough to know when they are out of their depth.</p>
<p>These are generative problems. They require a shift in our thinking, away from simply drawing boundaries and towards the ambitious goal of deep, probabilistic understanding. To the founders, the data scientists, and the investors, I say: look past the low-hanging fruit. The most valuable work is yet to be done, in the rich, untapped frontier of tabular data.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/bulentsoykan\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>